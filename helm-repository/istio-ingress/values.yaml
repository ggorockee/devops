defaults:
  # Name allows overriding the release name. Generally this should not be set
  name: ""
  # revision declares which revision this gateway is a part of
  revision: ""

  # Controls the spec.replicas setting for the Gateway deployment if set.
  # Otherwise defaults to Kubernetes Deployment default (1).
  replicaCount:

  kind: Deployment

  rbac:
    # If enabled, roles will be created to enable accessing certificates from Gateways. This is not needed
    # when using http://gateway-api.org/.
    enabled: true

  serviceAccount:
    # If set, a service account will be created. Otherwise, the default is used
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set, the release name is used
    name: ""

  podAnnotations:
    prometheus.io/port: "15020"
    prometheus.io/scrape: "true"
    prometheus.io/path: "/stats/prometheus"
    inject.istio.io/templates: "gateway"
    sidecar.istio.io/inject: "true"

  # Define the security context for the pod.
  # If unset, this will be automatically set to the minimum privileges required to bind to port 80 and 443.
  # On Kubernetes 1.22+, this only requires the `net.ipv4.ip_unprivileged_port_start` sysctl.
  securityContext: ~
  containerSecurityContext: ~

  service:
    # Type of service. Set to "None" to disable the service entirely
    type: NodePort
    ports:
    - name: status-port
      port: 15021
      protocol: TCP
      targetPort: 15021
    - name: http2
      port: 80
      protocol: TCP
      targetPort: 8080
    - name: https
      port: 443
      protocol: TCP
      targetPort: 8443
    annotations: {}
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    externalTrafficPolicy: ""
    externalIPs: []
    ipFamilyPolicy: ""
    ipFamilies: []
    ## Whether to automatically allocate NodePorts (only for LoadBalancers).
    # allocateLoadBalancerNodePorts: false

  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 2000m
      memory: 1024Mi

  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: {}
    autoscaleBehavior: {}

  # Pod environment variables
  env: {}

  # Labels to apply to all resources
  labels:
    istio: ingressgateway

  # Annotations to apply to all resources
  annotations: {}

  nodeSelector: {}

  tolerations: []

  topologySpreadConstraints: []

  affinity: {}

  # If specified, the gateway will act as a network gateway for the given network.
  networkGateway: ""

  # Specify image pull policy if default behavior isn't desired.
  # Default behavior: latest images will be Always else IfNotPresent
  imagePullPolicy: ""

  imagePullSecrets: []

  # This value is used to configure a Kubernetes PodDisruptionBudget for the gateway.
  #
  # By default, the `podDisruptionBudget` is disabled (set to `{}`),
  # which means that no PodDisruptionBudget resource will be created.
  #
  # To enable the PodDisruptionBudget, configure it by specifying the
  # `minAvailable` or `maxUnavailable`. For example, to set the
  # minimum number of available replicas to 1, you can update this value as follows:
  #
  # podDisruptionBudget:
  #   minAvailable: 1
  #
  # Or, to allow a maximum of 1 unavailable replica, you can set:
  #
  # podDisruptionBudget:
  #   maxUnavailable: 1
  #
  # You can also specify the `unhealthyPodEvictionPolicy` field, and the valid values are `IfHealthyBudget` and `AlwaysAllow`.
  # For example, to set the `unhealthyPodEvictionPolicy` to `AlwaysAllow`, you can update this value as follows:
  #
  # podDisruptionBudget:
  #   minAvailable: 1
  #   unhealthyPodEvictionPolicy: AlwaysAllow
  #
  # To disable the PodDisruptionBudget, you can leave it as an empty object `{}`:
  #
  # podDisruptionBudget: {}
  #
  podDisruptionBudget: {}

  terminationGracePeriodSeconds: 30

  # A list of `Volumes` added into the Gateway Pods. See
  # https://kubernetes.io/docs/concepts/storage/volumes/.
  volumes: []

  # A list of `VolumeMounts` added into the Gateway Pods. See
  # https://kubernetes.io/docs/concepts/storage/volumes/.
  volumeMounts: []

  # Configure this to a higher priority class in order to make sure your Istio gateway pods
  # will not be killed because of low priority class.
  # Refer to https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  # for more detail.
  priorityClassName: ""

mysite:
  enabled: true
  service:
    name: &istio-mysite-ingressgateway-name testbed-istio-mysite-ingressgateway
    annotations: {}
    type: NodePort
    labels:
      app: *istio-mysite-ingressgateway-name
      istio: &istio-mysite-selector mysite-ingressgateway
    selector:
      app: *istio-mysite-ingressgateway-name
      istio: *istio-mysite-selector
  ingress:
    name: *istio-mysite-ingressgateway-name
    annotations:
      kubernetes.io/ingress.class: alb
      alb.ingress.kubernetes.io/scheme: internet-facing
      alb.ingress.kubernetes.io/certificate-arn: "arn:aws:acm:ap-northeast-2:973531348166:certificate/d97fb2e6-2fdf-44d0-ad31-77b9d0c76df5"
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS":443}]'
      alb.ingress.kubernetes.io/ssl-redirect: "443"
      alb.ingress.kubernetes.io/load-balancer-name: istio-mysite-ingressgateway
      alb.ingress.kubernetes.io/healthcheck-port: '31363'
      alb.ingress.kubernetes.io/healthcheck-path: /healthz/ready
      alb.ingress.kubernetes.io/healthcheck-protocol: HTTP
      alb.ingress.kubernetes.io/security-groups: sg-0c85090ac3a2c7fab
    rules:
    - http:
        paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: *istio-mysite-ingressgateway-name
              port:
                number: 80
  deployment:
    name: *istio-mysite-ingressgateway-name
    image: docker.io/istio/proxyv2:1.20.2
    matchLabels:
      app: *istio-mysite-ingressgateway-name
      istio: *istio-mysite-selector


static:
  enabled: true
  service:
    name: &istio-static-ingressgateway-name istio-static-ingressgateway
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:ap-northeast-2:973531348166:certificate/d97fb2e6-2fdf-44d0-ad31-77b9d0c76df5"
      service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "http"
      service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"
      service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "60"
      service.beta.kubernetes.io/aws-load-balancer-name: *istio-static-ingressgateway-name
      service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
      service.beta.kubernetes.io/aws-load-balancer-type: "external"
    type: LoadBalancer
    labels:
      app: *istio-static-ingressgateway-name
      istio: &istio-static-selector static-ingressgateway
    selector:
      app: *istio-static-ingressgateway-name
      istio: *istio-static-selector
  deployment:
    name: *istio-static-ingressgateway-name
    image: docker.io/istio/proxyv2:1.20.2
    matchLabels:
      app: *istio-static-ingressgateway-name
      istio: *istio-static-selector

private:
  enabled: false
  service:
    name: &istio-pvt-ingressgateway-name istio-pvt-ingressgateway
    annotations: {}
    type: NodePort
    labels:
      app: *istio-pvt-ingressgateway-name
      istio: &istio-pvt-selector pvt-ingressgateway
    selector:
      app: *istio-pvt-ingressgateway-name
      istio: *istio-pvt-selector
  ingress:
    name: *istio-pvt-ingressgateway-name
    annotations:
      kubernetes.io/ingress.class: alb
      alb.ingress.kubernetes.io/scheme: internal
      alb.ingress.kubernetes.io/certificate-arn: "arn:aws:acm:ap-northeast-2:973531348166:certificate/d97fb2e6-2fdf-44d0-ad31-77b9d0c76df5"
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTP":80}, {"HTTPS":443},{"HTTP": 50051}, {"HTTP": 15021}]'
      alb.ingress.kubernetes.io/ssl-redirect: "443"
      alb.ingress.kubernetes.io/load-balancer-name: *istio-pvt-ingressgateway-name
      alb.ingress.kubernetes.io/healthcheck-port: '31652'
      alb.ingress.kubernetes.io/healthcheck-path: /healthz/ready
      alb.ingress.kubernetes.io/healthcheck-protocol: HTTP
    rules:
    - http:
        paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: *istio-pvt-ingressgateway-name
              port:
                number: 80
  deployment:
    name: *istio-pvt-ingressgateway-name
    image: docker.io/istio/proxyv2:1.20.2
    matchLabels:
      app: *istio-pvt-ingressgateway-name
      istio: *istio-pvt-selector

defaultIngress:
  enable: true
  name: &default-ingress-name testbed-istio-ingress
  # namespace: default
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: "internet-facing"
    alb.ingress.kubernetes.io/certificate-arn: "arn:aws:acm:ap-northeast-2:973531348166:certificate/d97fb2e6-2fdf-44d0-ad31-77b9d0c76df5"
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP":80},{"HTTPS":443}]'
    alb.ingress.kubernetes.io/ssl-redirect: "443"
    # alb.ingress.kubernetes.io/target-type: "ip"
    alb.ingress.kubernetes.io/load-balancer-name: istio-default-ingressgateway-v1
    alb.ingress.kubernetes.io/security-groups: sg-0c85090ac3a2c7fab
    alb.ingress.kubernetes.io/healthcheck-port: '30388'
    alb.ingress.kubernetes.io/healthcheck-path: /healthz/ready
    alb.ingress.kubernetes.io/healthcheck-protocol: HTTP
  rules:
  - http:
      paths:
      - backend:
          service:
            name: *default-ingress-name
            port:
              number: 80
        path: /
        pathType: Prefix

